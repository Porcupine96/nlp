// Generated by BUCKLESCRIPT VERSION 5.0.3, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Repromise = require("@aantron/repromise/src/js/repromise.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Wordnet$Wordnet = require("../infrastructure/Wordnet.bs.js");

function traverseRelations(synsetId, relationKind, visitedSynsets, $staropt$star, $staropt$star$1, param) {
  var maxDepth = $staropt$star !== undefined ? Caml_option.valFromOption($staropt$star) : 5;
  var target = $staropt$star$1 !== undefined ? Caml_option.valFromOption($staropt$star$1) : undefined;
  var exit = 0;
  if (maxDepth !== undefined && maxDepth === 0) {
    return Repromise.Rejectable[/* resolved */2](/* [] */0);
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Repromise.Rejectable[/* map */5](Belt_List.flatten, Repromise.Rejectable[/* andThen */4]((function (relations) {
                      var filteredRelations = Belt_List.keep(relations, (function (relation) {
                              return relation[/* relationKind */3] === relationKind;
                            }));
                      console.log(synsetId);
                      console.log(Belt_List.toArray(filteredRelations));
                      return Repromise.Rejectable[/* all */8](Belt_List.map(filteredRelations, (function (relation) {
                                        var match = relation[/* relFrom */1];
                                        var match$1 = relation[/* relTo */2];
                                        if (match === synsetId && !Belt_List.has(visitedSynsets, match$1, Caml_obj.caml_equal) && Caml_obj.caml_notequal(Belt_Option.map(target, (function (t) {
                                                      return t === match$1;
                                                    })), false)) {
                                          console.log("A");
                                          return Repromise.Rejectable[/* map */5]((function (result) {
                                                        return Belt_List.concat(filteredRelations, result);
                                                      }), traverseRelations(match$1, relationKind, /* :: */[
                                                          match$1,
                                                          visitedSynsets
                                                        ], Caml_option.some(Belt_Option.map(maxDepth, (function (d) {
                                                                    return d - 1 | 0;
                                                                  }))), Caml_option.some(match), /* () */0));
                                        } else if (match$1 === synsetId && !Belt_List.has(visitedSynsets, match, Caml_obj.caml_equal) && Caml_obj.caml_notequal(Belt_Option.map(target, (function (t) {
                                                      return t === match;
                                                    })), false)) {
                                          console.log("B");
                                          return Repromise.Rejectable[/* map */5]((function (result) {
                                                        return Belt_List.concat(filteredRelations, result);
                                                      }), traverseRelations(match, relationKind, /* :: */[
                                                          match,
                                                          visitedSynsets
                                                        ], Caml_option.some(Belt_Option.map(maxDepth, (function (d) {
                                                                    return d - 1 | 0;
                                                                  }))), Caml_option.some(match$1), /* () */0));
                                        } else {
                                          return Repromise.Rejectable[/* resolved */2](/* [] */0);
                                        }
                                      })));
                    }), Wordnet$Wordnet.relationsForSynset(synsetId)));
  }
  
}

function path(synsetId, relationKind, $staropt$star, param) {
  var maxLength = $staropt$star !== undefined ? Caml_option.valFromOption($staropt$star) : undefined;
  var exit = 0;
  if (maxLength !== undefined && maxLength === 0) {
    return Repromise.Rejectable[/* resolved */2](/* [] */0);
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Repromise.Rejectable[/* map */5](Belt_List.flatten, Repromise.Rejectable[/* andThen */4]((function (relations) {
                      var filteredRelations = Belt_List.keep(Belt_List.keep(relations, (function (relation) {
                                  return relation[/* relationKind */3] === relationKind;
                                })), (function (relation) {
                              return relation[/* relTo */2] === synsetId;
                            }));
                      return Repromise.Rejectable[/* all */8](Belt_List.map(filteredRelations, (function (relation) {
                                        return Repromise.Rejectable[/* map */5]((function (result) {
                                                      return Belt_List.concat(filteredRelations, result);
                                                    }), path(relation[/* relFrom */1], relationKind, Caml_option.some(Belt_Option.map(maxLength, (function (d) {
                                                                  return d - 1 | 0;
                                                                }))), /* () */0));
                                      })));
                    }), Wordnet$Wordnet.relationsForSynset(synsetId)));
  }
  
}

exports.traverseRelations = traverseRelations;
exports.path = path;
/* Repromise Not a pure module */
